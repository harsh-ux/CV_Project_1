# -*- coding: utf-8 -*-
"""sift_rift_combination.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-6_kWUVL6RwtRNv5p_NVs_g9vN75g0Zm
"""

import numpy as np
import pandas as pd 
from sklearn.model_selection import train_test_split

import cv2

import matplotlib.pyplot as plt
from tensorflow.keras.applications.vgg16 import VGG16
from datetime import datetime
import io
import itertools
from packaging import version



from tensorflow.keras import backend as K
import matplotlib.pyplot as plt
import numpy as np

import sklearn.metrics
from tensorflow.keras.optimizers import SGD

def normalize_mean_var(arr):
    arr -= np.mean(arr)
    arr /= np.var(arr)
    return arr

ritf_hist_train_path = "/content/RITF_hist_reduced_128_train_imc_50.npy"
ritf_hist_valid_path = "/content/RITF_hist_reduced_128_valid_imc_50.npy"

X_training_hists_reduced = np.load(ritf_hist_train_path)
X_valid_hists_reduced = np.load(ritf_hist_valid_path)

y_train_path = "/content/y_train_imc_50.npy"
y_valid_path = "/content/y_valid_imc_50.npy"

y_training = np.load(y_train_path)
y_validation = np.load(y_valid_path)

training_data_sift_hist = np.load('/content/sift_hist_50m_4k_training.npy')
valid_data_sift_hist = np.load('/content/sift_hist_50m_4k_validation.npy')

def norm_merge(arr1, arr2, alpha):
    a = normalize_mean_var(arr1.astype(np.float32)) * alpha
    b = normalize_mean_var(arr2.astype(np.float32)) * (1-alpha)
    return np.hstack((a, b))

training_data = norm_merge(X_training_hists_reduced, training_data_sift_hist, 0.6)
validation_data = norm_merge(X_valid_hists_reduced, valid_data_sift_hist, 0.6)

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import accuracy_score

def confusion_matrix_display(model, X_test, y_test, title):
    y_pred = model.predict(X_test)
    cm = confusion_matrix(y_test, y_pred)
    labels = np.unique(y_test)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=labels)
    disp.plot(cmap=plt.cm.Blues)
    disp.ax_.set_title('Confusion matrix: ' + title)

def Linear_SVM_classification(X_train, X_test, y_train, y_test):
    #LinearSVC
    from sklearn.svm import LinearSVC

    svc= LinearSVC(C=100.0, random_state=1, max_iter=1000, verbose=1)
    svc.fit(X_train, y_train)

    svcpred = svc.predict(X_test)
    cnf_matrix = metrics.confusion_matrix(y_test, svcpred)
    SVC_acc = metrics.accuracy_score(y_test, svcpred)

    print('Linear SVC accuracy: {}'.format(SVC_acc))
    return SVC_acc
        
Linear_SVM_classification(training_data, validation_data, y_training, y_validation)

results = []
for i in range(1, 101):
    alpha = i / 100
    print("alpha = ", alpha)
    training_data = norm_merge(X_training_hists_reduced, training_data_sift_hist, alpha)
    validation_data = norm_merge(X_valid_hists_reduced, valid_data_sift_hist, alpha)
    acc = Linear_SVM_classification(training_data, validation_data, y_training, y_validation)
    results.append(acc)

import matplotlib.pyplot as plt
def show_plot(x_data, y_data, x_label, y_label, title):
    plt.subplots(figsize=(12, 12))
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.plot(x_data, y_data)
    plt.title(title)
    plt.show()
    
show_plot([i/100 for i in range(1, 101)], results, 'Alpha', 'Accuracy', 'Accuracy-Alpha')

def get_max_alpha(arr):
    max_a = 0
    max_acc = 0
    for i, acc in enumerate(arr):
        if acc > max_acc:
            max_a = (i+1) / 100
            max_acc = acc
    return max_a, max_acc
            
alp_acc = get_max_alpha(results)
print("Max accuracy at alpha = {} with accuracy of {}".format(alp_acc[0], alp_acc[1]))

alpha = 0.81
training_data = norm_merge(X_training_hists_reduced, training_data_sift_hist, alpha)
validation_data = norm_merge(X_valid_hists_reduced, valid_data_sift_hist, alpha)
Linear_SVM_classification(training_data, validation_data, y_training, y_validation)

def Linear_SVM_classification_G(X_train, X_test, y_train, y_test):
    #LinearSVC
    from sklearn.svm import LinearSVC

    svc= LinearSVC(C=100.0, random_state=42, max_iter=1000, verbose=1)
    svc.fit(X_train, y_train)

    svcpred = svc.predict(X_test)
    cnf_matrix = metrics.confusion_matrix(y_test, svcpred)
    SVC_acc = metrics.accuracy_score(y_test, svcpred)

    confusion_matrix_display(svc, X_test, y_test, "Linear SVC")
    return SVC_acc
        
acc = Linear_SVM_classification_G(training_data, validation_data, y_training, y_validation)
print('Linear SVC accuracy: {}'.format(acc))

def RF_classification(X_train, X_test, y_train, y_test):
    from sklearn.ensemble import RandomForestClassifier
    clf = RandomForestClassifier(n_estimators = 100)
    clf.fit(X_train, y_train)

    pred = clf.predict(X_test)
    cnf_matrix = metrics.confusion_matrix(y_test, pred)
    RF_acc = metrics.accuracy_score(y_test, pred)

    print("Random Forest Accuracy:", RF_acc)
    confusion_matrix_display(clf, X_test, y_test, "Random Forst")
    
RF_classification(training_data, validation_data, y_training, y_validation)

def SVM_classification(X_train, X_test, y_train, y_test):
    #SVM
    from sklearn.svm import SVC

    for kernel in ('rbf', 'sigmoid'):
        svc= SVC(kernel = kernel)

        svc.fit(X_train, y_train)
        svcpred = svc.predict(X_test)
        cnf_matrix = metrics.confusion_matrix(y_test, svcpred)
        SVC_acc = metrics.accuracy_score(y_test, svcpred)

        print('SVC (kernel = {}): '.format(kernel),SVC_acc)
        title = 'SVC (kernel = {}): '.format(kernel)
        confusion_matrix_display(svc, X_test, y_test, title)
        
SVM_classification(training_data, validation_data, y_training, y_validation)

def gradient_boosting_classification(X_train, X_test, y_train, y_test):
    from sklearn.ensemble import GradientBoostingClassifier
    
    gb = GradientBoostingClassifier()

    gb.fit(X_train, y_train)
    gb_pred = gb.predict(X_test)
    cnf_matrix = metrics.confusion_matrix(y_test, gb_pred)
    gb_acc = metrics.accuracy_score(y_test, gb_pred)

    print('Gradient Boosting Classifier: ',gb_acc)
    title = 'Gradient Boosting Classifier'
    confusion_matrix_display(gb, X_test, y_test, title)
    
gradient_boosting_classification(training_data, validation_data, y_training, y_validation)