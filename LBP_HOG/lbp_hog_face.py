# -*- coding: utf-8 -*-
"""lbp_hog_face.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E8sTI7gZD6JBI5zICm24r-jCMdiNhKXm
"""

from imutils import paths
import numpy as np
import imutils
import cv2
import os

def face_detection(image):
    cascadePath = "haarcascade_frontalface_default.xml"
    detector = cv2.CascadeClassifier(cascadePath)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    rects = detector.detectMultiScale(gray, scaleFactor=1.05,
        minNeighbors=10, minSize=(30, 30),
        flags=cv2.CASCADE_SCALE_IMAGE)

    return rects

def load_face_dataset(inputPath, minSamples=15):
    imagePaths = []
    names = []
    for subdir in os.listdir(inputPath):
        subdirPath = os.path.join(inputPath, subdir)
        if not os.path.isdir(subdirPath):
            continue
        subdirImagePaths = list(paths.list_images(subdirPath))
        if len(subdirImagePaths) < 2:
            continue
        imagePaths.extend(subdirImagePaths)
        names.extend([subdir] * len(subdirImagePaths))
        
    (names, counts) = np.unique(names, return_counts=True)
    names = names.tolist()

    faces = []
    labels = []

    for imagePath in imagePaths:
        image = cv2.imread(imagePath)
        name = imagePath.split(os.path.sep)[-2]


        if counts[names.index(name)] < minSamples:
            continue

        boxes = face_detection(image)

        for (x, y, w, h) in boxes:
            try:
                faceROI = image[y:y+h, x:x+w]
                faceROI = cv2.resize(faceROI, (47, 62))
                faceROI = cv2.cvtColor(faceROI, cv2.COLOR_BGR2GRAY)

                faces.append(faceROI)
                labels.append(name)
            except:
                continue
                
    faces = np.array(faces)
    labels = np.array(labels)

    return (faces, labels)

from sklearn.metrics import f1_score
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import scipy.stats as stats
import numpy as np
import math
import imutils
import time
import cv2
import os
     
def cross_validation(input_data, cv=5, test_size=0.20, output=True, save_model=False):

    f1_scores = []
    
    random_states = np.random.randint(low=0, high=100, size=cv, dtype=int)

    (faces, labels) = load_face_dataset(input_data, minSamples=15)

    le = LabelEncoder()
    labels = le.fit_transform(labels)

    for random_state in random_states:
        X_train, X_test, y_train, y_test = train_test_split(faces, labels, test_size=test_size,
                                                            stratify=labels, random_state=random_state)

        recognizer = cv2.face.LBPHFaceRecognizer_create(
            radius=2, neighbors=16, grid_x=9, grid_y=9)

        recognizer.train(X_train, y_train)

        predictions = []
        confidence = []

        for i in range(0, len(X_test)):
            (prediction, conf) = recognizer.predict(X_test[i])
            predictions.append(prediction)
            confidence.append(confidence)

        f1_scores.append(f1_score(y_test, predictions, average="macro"))

    res = np.array(f1_scores, dtype="float32")

    if output:
        idxs = np.random.choice(range(0, len(X_test)), size=10, replace=False)

        fig, axs = plt.subplots(2, 5, figsize=(15, 6))
        fig.suptitle('Sample of Testing Data')
        for i, ax in enumerate(axs.flatten()):
            predName = le.inverse_transform([predictions[i]])[0]
            actualName = le.classes_[y_test[i]]
            face = np.dstack([X_test[i]] * 3)
            face = imutils.resize(face, width=250)
            cv2.putText(face, "actual : {}".format(actualName), (5, 25),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
            cv2.putText(face, "prediction: {}".format(predName), (5, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

        plt.imshow(face , cmap="gray")
        plt.title("Actual: {}\nPrediction: {}".format(actualName, predName))
        plt.axis("off")
        plt.show()
        
        plt.imsave("/content/face-{}.png".format(i), face , cmap="gray")
        
return res

f1_scores = cross_validation("/content/data" , cv=5 , save_model=True)
grab the mean of f1-scores
mu = np.mean(f1_scores)
sigma = np.std(f1_scores)
print("The mean of f1-scores is : " , mu)
print("The standard deviation of f1-scores is : " , sigma)
x = np.linspace(mu - 3sigma, mu + 3sigma, 100)
plt.plot(x, stats.norm.pdf(x, mu, sigma))
plt.title("F1-Score Distribution")
plt.xlabel("F1-Score")
plt.ylabel("Probability Density")
plt.show()